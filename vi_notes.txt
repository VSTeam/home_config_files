Appearance:
I changed the font to 7 for now because it lets me use the tall monitor.
To balance that, I did :set linespace=2 which moves lines a part a bit.
Also to balance that, I started playing with easier-on-the-eyes colors.
    My favorites are:
        If I need a light background to wake up: peach
        Non-black alternatives: desert, slate, darkblue
        Black background: murphy(green), pablo (white)
    ...
    Of these, I think slate is probably the best, because it washes out
    comments (of course, then they are hard to read, but the code as a
    whole becomes more readable). Darkblue also washes out comments,
    and I always like blue. My favorites are probably desert and murphy.
    Pablo I include mostly because it has a 'classic' look, with the
    black background and mostly white text.

If you want the best python completion, you should apparently try
:set completefunc? (while editing a .py, of course) to see if there is 
one. If not, you can do :set completefunc=pythoncomplete#Complete.
...
I'm not sure if this actually improved my completion any, so for now I
am not adding it to my .vimrc.
...
Also, cool tip (relates to issues I mention below): vim won't autocomplete
methods of objects using C-x C-o (it will if you already used that method,
e.g. C-x C-i)... HOWEVER, if you really want to look at methods and are
willing to type a bit to avoid having to open a terminal and go into 
ipython, then you can actually get these by typing the class name,
then a dot, then however much of the function you want and then doing
C-x C-o.

The zt zz zb commands are pretty useful. I keep grabbing the scrollbar
or moving my cursor around in situations where I could much more efficiently
use these: they move the screen (*not* the cursor) so that the current
cursor position is in the top/middle/bottom of the screen
... not to be confused with folding, the other major 'z' command class,
    or with ZZ which is the same as :x or :wq.


Vim also has an easy alternative to C-x C-i that apparently does similar
stuff: C-n and C-p seem to look for the next and previous words in the
workspace, or some such. I'm not sure how it works exactly, but it would
be faster and hence I would more likely use it a lot, therefore saving
typos and time.

Random cool stuff I found
shift + 3 (#) in vi mode will search backward (with wraparound) to the prev
instance of the word you are on.
If hls is set, then the search results stay highlighted til the next search,
which I think is annoying in most contexts. But you can quickly unhighlight
them with :noh.
The omni-completion C-x C-o is often useful (C-x C-i and C-x C-l are also nice)
for finishing a name, but the fantastic thing about it is that even if I know
the function, if I just want an arguments list then I can type it instead of
opening a parentheses. The only failure is that it won't work on methods
because vim doesn't know what class various objects are.
...
To work in a shell, do :sh and then C-v. Not sure how often this would be useful,
but I could see it being one way to avoid using a fuzzyfinder: you could do 
whatever find command in bash, and then call gi on that file to open it in the
current instance of vim.
...
DO NOT FORGET THE VERY USEFUL %
Also, learn about delimited blocks (maybe)
Also, don't forget marks. Also useful.
...
In insert mode, C-t and C-d indent and unindent. Note that this frees tab for
other things, which is how a lot of folks have mapped tab to C-x C-o.

The * and # are like / and ? on the *exact* word under the cursor.
You can use g* and g# if you like for the inexact word.

Using word delimiters in searches in general could cut down a lot on
false positives...

gf - go to file: work on imports in C/C++ as well as python.
    *BUT* you need to do :cd to the right root directory (it won't find
    things as dynamically as one might hope, in python it pretty much
    just replaces . with / and tries to open.


### Ctags:

here's the code used in the google tech talk:
:!ctags -R .
:tag init
:tnext
----
:grep "\<K_HOME\>" **/*.h      ... I think K_HOME is what he's looking for here
:cnext
.... I don't quite follow it and I think at least part of it is specific to C 
code (the second option is a search of header files, I think; I'm not sure
how * differs from ** but maybe ** handles /'s(?) ) but the idea once I know
it is probably good.



################################

Basic buffer/tab/window management:
  I constantly seem to need to review this stuff, so I am putting it
  at the top for quick reference.
** Buffers within a window **
To list your open buffers, do :ls. To jump directly to a particular
buffor, use :b # where the number is the number in the buffer list. You
can also use the name of the buffer, but you have to give the full path
which is a pain (there are apparently plugins to avoid this)
  Within a window, you can use :bn and :bp 
(for :bnext and :bprev) to move back and forth between
buffers. You can use :bn # and :bp # to move more than one at a time.
If vim is being a pain about moving, you need to :set hidden.
  When opening a new buffer, if you aren't sure whether it is open,
you should use :dr (for :drop) filename, which prevents you from getting two
copies of a single file (that can happen if you use :e).
  To close a buffer, it is best to use :bdelete. You can use :bwipeout,
but that will dump some potentially useful data that you can use if you
reopen that buffer.
---
I downloaded a package called bufkill, which emulates emacs behavior, so now 
if I do :bd it should delete a buffer along with the window whereas :BD should
delete the buffer without closing the window. Not only that, but there is also
scrolling per window: :BB and :BF will scroll fwd/backward thru buffers last
accessed in any given window. There is one level of undo in deleting buffers,
although I'm not sure how to undo.
---
** Tabs **
These are viewports, or collections of windows. You shouldn't use them as
'buffer replacements', but you can use them effectively to group together
collections of windows on related files. Sometimes you might want to
use two tabs for one set of files, in which case you should stick the
most commonly paired files in the same tab so that you have to switch tabs
as rarely as possible.
  You can use :tabr (tabrewind; it uses an rewind rather than first because
tabf is a different command), :tabl and :tabn :tabp to switch tabs. In gvim,
you can also use the mouse. You probably shouldn't be switching tabs too
often, so that's not a big deal. You can also do :tabn #, :tabp #, and
you can use :tabs :tabn # the same way you would use :ls :b #.
  To open a tab, you can do :tabnew or if you want a specific file, :tabnew
filename. To close a tab, you can use :q if you also want to close the file and
there is only one window, or :tabc to close the tab without affecting
the buffer list.
   Someone suggested putting this in .vimrc to get tab commands to behave
a bit more like window commands:
map <C-t><up> :tabr<cr>
map <C-t><down> :tabl<cr>
map <C-t><left> :tabp<cr>
map <C-t><right> :tabn<cr>
I'll make a note if/when I add that to my .vimrc.
** Windows **
If you want to split the screen on a tab and open a file, you should do
:vsplit or :split. If you just want to split, you can do the vi-mode
C-w s or C-w v.
  To navigate windows, do C-w (movement). You can also use C-w t and C-w b
to go to the top-left/bottom-right windows on a tab. To close a window, do
C-w c, and to close all other windows in a tab do C-w o.

**Some basic tools I often forget**
gc - if used in vi mode and followed by a movement, or if used in visual
     mode with something highlighted, this formates the text. Very useful
     if you are in latex; probably not such a big deal in python although
     it might auto-reset your indentations for lines that go over. I'm not
     sure about that.
Opening files - This is best done using F2 (nerdtree), :Sex, or
                :dr if you are willing to type the full filename.
                The built-in :Sex is maybe a tiny bit more convenient than
                NerdTree when you want another file in the current
                directory or a neighboring one, but otherwise NerdTree
                is probably nicer.

************************************************************************
******** I am at ch6, p. 117(pdf) or 95(book) in LtVVE, 7th ed *********
************************************************************************

*Opening vi*
vi +3 file
    opens file and puts cursor on line 3
vi + file
    opens file at end instead of beginning.
vi /foo file
    opens file and puts cursor at 1st occurence of foo
vi -R file
    opens as read-only. A good way to make sure you don't accidentally
    change code when you open something for reference.
      The command view file is equivalent.
    If you do want to make changes, you can do :w! or :wq! to override
    the read-only (assuming you have permission), but the warning might remind
    you of a problem and then you could do :w newfilename to save a copy.
vi -r
    Opens any recovered buffers after the system goes down.
    vi -r filename will open just one specific recovered buffer.
vi file1 file2 ...
    Opens vi on multiple files.


**********************************************************************
************************ Part II: ex commands ************************
**********************************************************************

*Basic file commands*
(I already had these above, but I'm repeating because they are ex commands.)
:sh will take you to a shell, then C-d will get you back to vim when done.
    Doing !`command` lets you send just one command to the shell instead.
:w, :q, :x, :q! are very standard. Don't use :wq or ZZ.
    If you want to write to a new file name, do :w `filename`.
    If you need to overwrite an existing file, do :w! `filename`.
:e `filename` to open a file from ex mode. :e! reopens the current file.


*Regular Expressions*
The escape character, to treat any regexp character as text, is \, and
of course \\ produces a text \. Other special characters are:
   / ---  the delimiter for the regexpr
   . ---  allows any *single* character in that position
   * ---  at the end of a string, allows 0 or more of the preceding character
          (so trades* would match trade, trades, tradess, etc.)
          If preceded by another special regexpr character (not escaped), it
          will match whatever that is. So .* represents any string of any size.
          Note that in most programs, * does what .* does here. (bad vi!)
   ^ and $ --- requires the expression following/preceding it to be found at
               the beginning/end of a line. I assume they strip whitespace 1st.
   [abc] --- matches any character listed between the brackets.
             You can use [a-c] to represent any character between a and c
             in ascii coding... you should probably only use this for two
             lowercase letters, two uppercase, or two digits.
             Any combination of those rules is okay, for instance [1-9a-z.,]
             will match any digit except zero, any lower case letter, and
             any period or comma.
    [:keywd:] --- used inside of [] to refer to POSIX classes
          classes include
            [:alpha:] [:lower:] [:upper:] [:alnum:] (alphanumeric)
            [:space:] (whitespace) [:blank:] (space and tab only)
            [:punct:] [:graph:] (visible--all but whitespace)
            [:digit:] [:xdigit:] (hexadecimal digits)
    [.unit.] --- Treats the string inside as a single unit. Used inside of []
                 to do things like [[.bid.][.ask.]], which is otherwise hard
                 to do.
              note: there's also an [= =], but I doubt I'll find that useful.
               See LTVVE page 99 of the pdf, 77 of the book.
   ~ --- refers to whatever regular expression was last used. If it's used
         as in the 'search for' pattern, it looks for the last 'search for'
         pattern and if in the 'replace with' pattern it looks for the last
         'replace with pattern'. The behavior has some quirks, so not 
         recommended.
   \<ab and ab\> --- These will look for when ab begins or ends a word,
                     respectively (words being delimited by whitespace or
                     punctuation). Note that you needn't escape < and >.
There are also some funkier characters out there, some of which need to
be escaped if you want to search for them:
  & --- can only be used in the replacement string: it puts whetever the
        search pattern was (could be a string, or a variable pattern in which
        case it will use the actual string found for each instance) into the
        replacement pattern, so for example you could use
         :s/time/&s   as shorthand for :s/time/times.
  \( and \) --- very useful but a bit complicated to explain. They delimit
                'search variables' that can be referenced by \1, \2, \3, etc.
                They should only be used in the search pattern.
  or --- used to choose between variables as set using \( and \).
  \1, \2 \3, etc --- used only in the replacement pattern, to refer to
                     items from the search pattern marked by \( and \).
  \u and \l --- In the context of the search-variables above, these can be
                used to change the case of the first character of the
                replacement. See LTVVE p99 (pdf) or 77 (book)
  \U and \L, \e --- same as \u and \l except everything in the replacement
                    string (not just the first letter) is forced to the
                    desired case; you can stop it early by putting \e in
                    to signal 'end of force case'
      Now, we need an example:
         %s/\(ask\) or \(bid\)/\2 or \1/
            will swap 'ask' with 'bid' in the whole buffer. On the other hand
         %s/\(ask\) or \(bid\)/\u\1 \u2/
            will capitalize the first letter of all instances of 'bid' and 
            'ask' in the buffer. 
The rules above are fairly complete, but in order to absorb them you need
to use them or regularly look at examples (you can't realistically use them
until you've seen enough examples to at least think of it, after all).
The book pp 103-116 (pdf numbering) has a lot of pattern-matching examples,
and also examples of how to use various commands and options to get desired
behavior. It is probably worth rereading periodically at least until I am
happy with my ability to do search-and-replace without wasting time.

*****************************************
* Vim-specific features *****************
*****************************************

Some of the discussion below largely supercedes bits of the vi discussion
above, eg it is probably a good idea to use vim methods for multiple editing
and avoid the vi approach.
A few things I mentioned above inadvertantly were also not valid vi commands.
The only ones I know of are
u - in vi you only get one undo; pressing u again undoes the undo
    in vim repeated u's do repeated undoes.
Ctl-R - this is the vim redo, and has no analogue (other than u) in pure vi.

* Code folding in vim *
If you want code folding, you should probably do :set foldmethod=indent, 
    although it does seem as though folding comments (docstrings esp) could 
    be handy.
Then, you can fold all with zM and unfold all with zR. You can fold and 
    unfold one level at a time (in the whole buffer) with zm and zr, and 
    you can toggle folding on a particular line with za.

THIS IS WHERE I AM IN COPYING NOTES OVER. IN TERMS OF THE BOOK, MY
REREADING HAS REACHED THE START OF PART II ON VIM. WHAT I NEED TO DO
IS FINISH COPYING THIS STUFF OVER AND THEN FIGURE OUT WHERE TO PUT THE
INFORMATION LISTED ABOVE IT (WHICH IS ALL STUFF I CAME ACROSS AFTER HAVING
WRITTEN THESE NOTES) AS WELL AS REREADING SOME OF THE OTHER VIM STUFF.
...........
THE GOAL IS TO DELETE THESE NOTES, WHICH HAVE BE COME A DINOSAUR, AND REPLACE
THIS FILE WITH 'vim_new_notes.txt' WHEN I'M DONE. LEARNING/RELEARNING SOME
BASIC FEATURES ALONG THE WAY IS GOOD, BUT THE REAL GOALS ARE TO HAVE:
 (a) a faster reference when I forget something
 (b) a quicker hyperreference to skim now and then for refreshing my sense
     of possibilities (obviously if I know of a feature and can't recall the
     command, google is fine, but I have to know it exists in order to look)
 (c) a leaner discussion of basic features so that I can put in extended
     discussions, if necessary, of harder topics like regexp's, ctags,
     and plugin functionality.
 (d) a reference that is more willing to rely on the content of the book
     for explaining the stuff that I can't do justice in quick notes.
...........

* Vim for programmers *
I already discussed vi for programming above, and a tiny blurb with no detail
on how vim does better. But there's a whole chapter, Ch 14, on this stuff.
That, along with buffers tabs and windows, is the last thing I need to study
before I am ready to be a solid beginnig vim user and cut the tie with
jedit.

* Scripts *
Chapter 12 of LTVVE is a full 20 page tutorial on vim scripting.
Oddly enough, I can't find a section on .vimrc, so it seems to be missing the
big picture of how things fit together, but it goes into a fair amount of
detail in terms of the mechanics of writing a .vim file.
  I also added a link to my google doc on vi that talks about extending
vim using python.
  It doesn't really belong here, but it just occured to me that I should look
into how to change the font size. Super-small would be a pain, but I could
definitely handle smaller than I currently have, and that way fit more code
on the screen.

* gvim *
Chapter 13 of LTVVE discusses gvim, most of which is self-explanatory.
It does discuss window customization (toolbars, etc) which I will likely need
to know eventually so that I can get rid of the toolbar and save on screen 
space.

* random stuff *
Chapter 15 of LTVVE discusses 'other stuff'. The only really useful looking
stuff I saw were:
  make html file out of code
    (I suspect that there a way to do latex also)
  use vim to directly edit text on remote machines
    (you could obviously ssh in and then call up vim, but the idea is that
     you can use gvim rather than terminal vim if you do it from vim... so
     then you can get some of the amenities of emacs)
  vimdiff
     (kind of like meld, not as pretty but I may discover that it's handier)
  saving cursor position in large files
     (so you don't have to start at the top and find your spot every time).
  abbreviations
     (see p 324... I've been using some of them already above like nu for 
      number)
