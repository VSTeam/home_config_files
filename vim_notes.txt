Things to try to use
=====================

Use character searches and text objects more.
Use [[ and ]] more.
Use marks and macros more.
Use the command window for searches and substitutions.
Use the gd command more.
Use tags.
Use c-j and c-k in fuzzyfinder.



NOTES
=====

# Go into insert mode.
i I a A r s c_ cc C o O

# edits
# Most of these accept visual mode selections, movement commands (in
# which case they go from cursor to target) or text objects.
y_ d_ Y* D yy dd p P x X
> < gq J
remember that c-t and c-d are insert equivs of >> and <<
u and c-r. Remember there *is* an undo tree if you need it, even if
           I'm not sure how to use it. The Gundo plugin can help.


# text objects
:help text-objects
------------------
iw aw iW aW is as ip ap
i" a" i( a(   ...   here `(` is literal, not a `sentence` as in the movement
                    commands (/)

# movements
e E w W b B
% ( ) { } [[ ]]    ... in python, the mosd useful are %, { & }, and [[ & ]]
[( ]) [{ ]}        ... in a brace-delimited language, [{ and ]} are impt.
+ - h j k l $ ^
t_ T_ f_ F_ ; ,
/___ ?___ n N * #
gg, G g(num)
gd    ...    go to local declaration of a variable (so cool!)

# scrolling: with cursor mvmnt, screen only, screen only by line, cursor only
c-f c-b c-u c-d 
zt zz zb
c-e c-y
H M L

# marks
:help marks
-----------
`(mark), '(mark) for mark or beginning of line with mark... 
`` '' for prev
m(a-z): set a local mark, only valid in this file
m(A-Z): set a global mark over all files in the vim session
'_ and `_ are movement commands. They can be used with, e.g., d y c gq > etc.
Setting a mark at one end of some block, navigating to the other end, and and
then doing (edit_command)(` or ')(mark letter).
:marks lists all marks (probably only global ones and those in the current 
                        file, that is, I assume it depends on context.)
:marks AaB lists marks A, B, and a only.
[' and ]' let you page through all lowercase marks in file
[` and ]` let you page through all uppercase marks in file
see :help delmarks for deleting marks.
----
There are several special marks other than previous. I need to read about them
in Practical Vim.


# registers (sometimes called buffers, esp in non-vim vi)
:help registers
---------------
:reg to see all registers
"(a-z) to access a register. 
specials: "" and "1 most recent deletion/yank "2 - "9 count back older 
          deletions/yanks. "0 is the most recent yank.
          "+ is the system clipboard. "% is the file name. ": is most recent
          ex command. ". is the most recent edit. "_ is the black hole, mostly
          useful if you want to delete without clobbering the current "".
          "= is best illustrated by example: "=5*5p pastes 25 after the cursor.
(register)(yank or delete command) will store something in the register.
q(register) will begin a macro, that is, all keystrokes go into the register
            until you hit q again.
(register)(p or P) will paste.
    Note: p/P's behavior depends on whether a register is full- or partial- 
          line. I'm still unclear on precisely what determines this, but I 
          do know that yy, dd, or anything on a Shift-v selection
          generate line register.
@(register) executes a register. @@ will re-execute the most recent macro.
C-r will insert the contents of a register in insert mode.
---
Note that there are 2 mostly distinct use cases, text and macros. So typically,
    we would use [y/d and p/P/C-r], or [q and @], and not mix them. Also note
    that the syntax differs: the register precedes text stuff (except C-r)
    but comes after q and @.
A-Z refer to the same registers. The difference is that if you copy or record
    a macro with a capital register, vim appends rather than replaces.

# basic ex commands
:w :e :x :=
(range)m(lineno)    and   (range)t(line)   will [Move] or [copy To]
If you want to use buffers for ex copy/paste command, you can:
    (linerange)ya x     ...   yanks to buffer x
    (lineno)pu x        ...   puts (pastes) buffer x after line (linenu)
:(range)s/pattern/replacement/[gc]
:g/pattern/(command)  ... search for pattern to get a line range, then
                          run (command) on that line range, e.g.,
                          g/def/nu gives line numbers of lines with 'def'.
:(lineno)r (filename)   ...  reads in a file after (lineno) of current buffer.
| is the command concatenator (it behaves like ; in shell, NOT like |)


# line numbers/ranges
Basic line ranges look like 23,56
For any command that takes a range or number, a blank means current line.
    In a line range, leaving one side of the `,` blank also means current line.
Special line symbols include . for current line, $ for last line, 0 for the
    beginning of file (1 works just as well some of the time, but you need 0
    if you want to paste something in front of line 1). `%` means `0,$`.
Relative lines are given by +(num) and -(num), they are relative to current 
    line. + and - by themselves mean +1 and -1. Remember that you can omit
    the `.` if that is one side of your line range.


# Shell commands
! escapes to the shell, :sh opens a shell *but* be aware they don't read 
    bashrc so aliases aren't available.
the ConqueTerm plugin fixes this, although it still isn't the greatest shell,
    and the color interaction is a problem (that might be fixable)
Generally it's preferable to use built-in commands like :make if you can.
    If theres no built-in and you use a shell command regularly, it might be
    worth creating a custom vim command to call it.
Keep in mind that many shell tools, like git, have vim plugins like Fugitive
    available so you can interact with them.
Shell tools can be used inside vim for text purpose, in (loosely) two ways:
    - Reading text in: example is :r(lineno) !date, which reads in the date
      after the line given (by default, the current line). In this case,
      the tool's stdin is determined by your call, but stdout is dumped in
      the current buffer after the indicated line.
    - Altering text: (linerange)!sort, for example, would treat the lines
      in the linerange as stdin, and would replace that block with the output
      of sort in the current buffer.
    - This is likely to be error-prone, but you can undo any mistakes. If I
      learn sed and awk well, there's some chance that I could find these
      features handy. Hypothetically I could also write custom python code
      and then use this, although presumably using vim-python would be better.



*****************************
STILL WORTH READING IN LTVAVE
*****************************

-page 55 through 124 is advanced vi stuff not covered in the notes above.
 much of it I know but need to add to this. The main thing I need to really
 learn is the full power of regexps in search and replace.
-page 169 documents vim's additions to the vi regexp language.
-Ch 14, starting p. 239, covers vim enhancements for programming. I really
 ought to know this stuff.

I should some sections of notes about tabs, buffers, and window, even though
I don't plan to reread those sections of LTVAVE.

*** Most of the practical vim book is worth reading carefully ***
*** I should go through VimCasts carefully at some point ***

********************
* Topics to master *
********************

Indentation: It would be nice to learn to write my own indentation control,
             but at the least I should learn better ways to override auto
             indent.



































#############################################################
#############################################################
####################### OLD NOTES ###########################
#############################################################
#############################################################




Search and Replace
******************
I already covered search (I need to learn patterns, tho).
    One way to search-and replace is to do n. or N.
    This is sometimes easier than trying to figure out the range for :s
The general search pattern is :X/old/new(/gc), where X is line range.
X can be blank (thisline), %(file), `3,44` (lines 3 to 44), `7,$` (7 to eof),
    .,+ (this line and the next), -3,+5 (three lines earlier to 5 lines later).
X can also be the output of a filter... :Xg/pattern returns the lines on which
    `pattern` is found, so :Xg/pattern/s/old/new/gc will affect those lines
    in range X (which itself could be the output of a filter but let's not get
    crazy) in which pattern was found.
Note: if you do a one-live substitution, that is :s/old/new/g, then you can
    repeat it as many times as you like with just :s on new lines (until you
    do a different substitution)
Note: Both searches and substitutions can be much more useful with regular
    expressions (as can shell commands)... not only can the regex's be useful,
    but *not* knowing them can actually be a problem in that they mess up
    your simple searches. See Ch6 of LTVVE (starts page 93 of pdf), which
    is all about :s and regular expressions and their vim macro extensions.
Note: this is more search than search-and-replace, but the / does emacs-style
    incrsearch... EXCEPT if you forget to hit enter and instead hit C-c, you
    go back to the starting point!

Occasionally useful things
**************************
:sh,  :!(shell command), :=  (to find how many lines) 
:r filename (appends that file to the open file)
If you have spellcheck on, z= gives alternatives.



Tabs, buffers, and Windows
****************
C-W ... t, b, arrow, p, c, o
:tabnew, :tabclose, C-pgup, C-pgdn
:bd, :BD, :bn, :bp, :ls, :b#  ... C-6 toggles 2 buffers, can be handy


************
* Appendix *
************

*Regular Expressions*
The escape character, to treat any regexp character as text, is \, and
of course \\ produces a text \. Other special characters are:
   / ---  the delimiter for the regexpr
   . ---  allows any *single* character in that position
   * ---  at the end of a string, allows 0 or more of the preceding character
          (so trades* would match trade, trades, tradess, etc.)
          If preceded by another special regexpr character (not escaped), it
          will match whatever that is. So .* represents any string of any size.
          Note that in most programs, * does what .* does here. (bad vi!)
   ^ and $ --- requires the expression following/preceding it to be found at
               the beginning/end of a line. I assume they strip whitespace 1st.
   [abc] --- matches any character listed between the brackets.
             You can use [a-c] to represent any character between a and c
             in ascii coding... you should probably only use this for two
             lowercase letters, two uppercase, or two digits.
             Any combination of those rules is okay, for instance [1-9a-z.,]
             will match any digit except zero, any lower case letter, and
             any period or comma.
    [:keywd:] --- used inside of [] to refer to POSIX classes
          classes include
            [:alpha:] [:lower:] [:upper:] [:alnum:] (alphanumeric)
            [:space:] (whitespace) [:blank:] (space and tab only)
            [:punct:] [:graph:] (visible--all but whitespace)
            [:digit:] [:xdigit:] (hexadecimal digits)
    [.unit.] --- Treats the string inside as a single unit. Used inside of []
                 to do things like [[.bid.][.ask.]], which is otherwise hard
                 to do.
              note: there's also an [= =], but I doubt I'll find that useful.
               See LTVVE page 99 of the pdf, 77 of the book.
   ~ --- refers to whatever regular expression was last used. If it's used
         as in the 'search for' pattern, it looks for the last 'search for'
         pattern and if in the 'replace with' pattern it looks for the last
         'replace with pattern'. The behavior has some quirks, so not 
         recommended.
   \<ab and ab\> --- These will look for when ab begins or ends a word,
                     respectively (words being delimited by whitespace or
                     punctuation). Note that you needn't escape < and >.
There are also some funkier characters out there, some of which need to
be escaped if you want to search for them:
  & --- can only be used in the replacement string: it puts whetever the
        search pattern was (could be a string, or a variable pattern in which
        case it will use the actual string found for each instance) into the
        replacement pattern, so for example you could use
         :s/time/&s   as shorthand for :s/time/times.
  \( and \) --- very useful but a bit complicated to explain. They delimit
                'search variables' that can be referenced by \1, \2, \3, etc.
                They should only be used in the search pattern.
  or --- used to choose between variables as set using \( and \).
  \1, \2 \3, etc --- used only in the replacement pattern, to refer to
                     items from the search pattern marked by \( and \).
  \u and \l --- In the context of the search-variables above, these can be
                used to change the case of the first character of the
                replacement. See LTVVE p99 (pdf) or 77 (book)
  \U and \L, \e --- same as \u and \l except everything in the replacement
                    string (not just the first letter) is forced to the
                    desired case; you can stop it early by putting \e in
                    to signal 'end of force case'
      Now, we need an example:
         %s/\(ask\) or \(bid\)/\2 or \1/
            will swap 'ask' with 'bid' in the whole buffer. On the other hand
         %s/\(ask\) or \(bid\)/\u\1 \u2/
            will capitalize the first letter of all instances of 'bid' and 
            'ask' in the buffer. 
The rules above are fairly complete, but in order to absorb them you need
to use them or regularly look at examples (you can't realistically use them
until you've seen enough examples to at least think of it, after all).
The book pp 103-116 (pdf numbering) has a lot of pattern-matching examples,
and also examples of how to use various commands and options to get desired
behavior. It is probably worth rereading periodically at least until I am
happy with my ability to do search-and-replace without wasting time.
